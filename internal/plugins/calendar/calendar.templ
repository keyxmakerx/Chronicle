// calendar.templ renders the calendar UI: setup page, monthly grid view,
// event creation modal, and event display. The grid uses a CSS grid matching
// the weekday count. Season colors are displayed as subtle backgrounds on day cells.

package calendar

import (
	"fmt"
	"strconv"
	"github.com/keyxmakerx/chronicle/internal/plugins/campaigns"
	"github.com/keyxmakerx/chronicle/internal/templates/layouts"
)

// CalendarSetupPage renders the initial setup when no calendar exists yet.
templ CalendarSetupPage(cc *campaigns.CampaignContext, csrfToken string) {
	@layouts.App("Calendar - Setup") {
		<div class="max-w-lg mx-auto py-12">
			@calendarSetupForm(cc, csrfToken)
		</div>
	}
}

// CalendarSetupFragment renders the setup form as an HTMX fragment.
templ CalendarSetupFragment(cc *campaigns.CampaignContext, csrfToken string) {
	<div class="max-w-lg mx-auto py-12">
		@calendarSetupForm(cc, csrfToken)
	</div>
}

// calendarSetupForm renders the form to create a new calendar.
templ calendarSetupForm(cc *campaigns.CampaignContext, csrfToken string) {
	<div class="card p-8 text-center space-y-6">
		<div>
			<i class="fa-solid fa-calendar-days text-4xl text-accent mb-3"></i>
			<h1 class="text-xl font-bold text-fg">Create Your Calendar</h1>
			<p class="text-sm text-fg-secondary mt-1">
				Set up a custom calendar for your world with unique months, weekdays, moons, and more.
			</p>
		</div>
		<form
			method="POST"
			action={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/calendar", cc.Campaign.ID)) }
			class="space-y-4 text-left"
		>
			<input type="hidden" name="csrf_token" value={ csrfToken }/>
			<div>
				<label class="block text-sm font-medium text-fg-body mb-1">Calendar Name</label>
				<input type="text" name="name" value="Campaign Calendar" class="input w-full" placeholder="e.g. The Reckoning of Ages"/>
			</div>
			<div>
				<label class="block text-sm font-medium text-fg-body mb-1">Epoch / Era Name</label>
				<input type="text" name="epoch_name" class="input w-full" placeholder="e.g. DR, Age of Fire, Third Era"/>
				<p class="text-xs text-fg-muted mt-1">Optional. Displayed after the year number (e.g. "1492 DR").</p>
			</div>
			<div>
				<label class="block text-sm font-medium text-fg-body mb-1">Starting Year</label>
				<input type="number" name="start_year" value="1" class="input w-full"/>
			</div>
			<div class="pt-2">
				<button type="submit" class="btn-primary w-full">
					<i class="fa-solid fa-plus mr-2"></i> Create Calendar
				</button>
				<p class="text-xs text-fg-muted mt-2 text-center">
					You can customize months, weekdays, and moons after creation.
				</p>
			</div>
		</form>
	</div>
}

// CalendarPage renders the full calendar page with monthly grid.
templ CalendarPage(cc *campaigns.CampaignContext, data CalendarViewData) {
	@layouts.App(data.Calendar.Name) {
		<div class="h-full flex flex-col -mx-5 -my-4">
			@calendarHeader(cc, data)
			<div class="flex-1 overflow-y-auto px-6 py-4">
				@calendarGrid(cc, data)
			</div>
		</div>
		if data.IsScribe {
			@eventCreateModal(data)
		}
	}
}

// CalendarGridFragment renders just the grid area for HTMX swaps.
templ CalendarGridFragment(cc *campaigns.CampaignContext, data CalendarViewData) {
	@calendarHeader(cc, data)
	<div class="flex-1 overflow-y-auto px-6 py-4">
		@calendarGrid(cc, data)
	</div>
}

// calendarHeader renders the month/year navigation and current date info.
templ calendarHeader(cc *campaigns.CampaignContext, data CalendarViewData) {
	<div class="bg-surface border-b border-edge px-6 py-3 flex items-center justify-between shrink-0">
		<div class="flex items-center gap-4">
			<!-- Prev/Next month navigation -->
			<div class="flex items-center gap-1">
				<a
					href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/calendar?year=%d&month=%d", data.CampaignID, prevYear(data), prevMonth(data))) }
					class="p-2 rounded-md hover:bg-surface-alt text-fg-secondary hover:text-fg transition-colors"
					title="Previous month"
				>
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
					</svg>
				</a>
				<a
					href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/calendar?year=%d&month=%d", data.CampaignID, nextYear(data), nextMonth(data))) }
					class="p-2 rounded-md hover:bg-surface-alt text-fg-secondary hover:text-fg transition-colors"
					title="Next month"
				>
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
					</svg>
				</a>
			</div>
			<!-- Month name + year -->
			<div>
				<h1 class="text-lg font-semibold text-fg">
					if data.CurrentMonthDef() != nil {
						{ data.CurrentMonthDef().Name }
					}
					{ " " }
					{ strconv.Itoa(data.Year) }
					if data.Calendar.EpochName != nil && *data.Calendar.EpochName != "" {
						{ " " + *data.Calendar.EpochName }
					}
				</h1>
				<!-- Season indicator -->
				if season := data.CurrentSeason(1); season != nil {
					<p class="text-xs text-fg-muted">
						<span class="inline-block w-2 h-2 rounded-full mr-1" style={ fmt.Sprintf("background:%s", season.Color) }></span>
						{ season.Name }
					</p>
				}
			</div>
		</div>
		<div class="flex items-center gap-3">
			<!-- "Today" button to jump to current date -->
			if data.Year != data.Calendar.CurrentYear || data.MonthIndex != data.Calendar.CurrentMonth {
				<a
					href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/calendar", data.CampaignID)) }
					class="btn-secondary text-xs"
				>
					<i class="fa-solid fa-crosshairs mr-1"></i> Today
				</a>
			}
			<!-- Moon phases for today -->
			if len(data.Calendar.Moons) > 0 {
				<div class="flex items-center gap-2">
					for _, moon := range data.Calendar.Moons {
						<span
							class="text-xs text-fg-secondary"
							title={ fmt.Sprintf("%s: %s", moon.Name, moon.MoonPhaseName(data.AbsoluteDay(data.Calendar.CurrentDay))) }
						>
							{ moonPhaseIcon(moon.MoonPhase(data.AbsoluteDay(data.Calendar.CurrentDay))) }
						</span>
					}
				</div>
			}
			<!-- Settings link (Owner only) -->
			if data.IsOwner {
				<a
					href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/calendar/settings", data.CampaignID)) }
					class="p-2 rounded-md hover:bg-surface-alt text-fg-secondary hover:text-fg transition-colors"
					title="Calendar settings"
				>
					<i class="fa-solid fa-gear text-sm"></i>
				</a>
			}
			<!-- Add event button (Scribe+) -->
			if data.IsScribe {
				<button
					class="btn-primary text-xs"
					onclick="document.getElementById('event-modal').classList.remove('hidden')"
				>
					<i class="fa-solid fa-plus mr-1"></i> Event
				</button>
			}
		</div>
	</div>
}

// calendarGrid renders the weekday headers and day cells.
templ calendarGrid(cc *campaigns.CampaignContext, data CalendarViewData) {
	if data.CurrentMonthDef() == nil {
		<div class="card p-6 text-center text-fg-secondary">
			<p>No months configured. Add months in calendar settings.</p>
		</div>
	} else {
		<div
			class="grid gap-px bg-edge rounded-lg overflow-hidden"
			style={ fmt.Sprintf("grid-template-columns: repeat(%d, minmax(0, 1fr))", data.Calendar.WeekLength()) }
		>
			<!-- Weekday headers -->
			for _, wd := range data.Calendar.Weekdays {
				<div class="bg-surface-alt px-2 py-2 text-center text-xs font-semibold text-fg-secondary uppercase tracking-wider">
					{ wd.Name }
				</div>
			}
			<!-- Empty cells before day 1 -->
			for i := 0; i < data.StartWeekdayOffset(); i++ {
				<div class="bg-surface min-h-[80px]"></div>
			}
			<!-- Day cells (use leap-year-aware day count) -->
			for day := 1; day <= data.CurrentMonthDays(); day++ {
				@dayCell(data, day)
			}
			<!-- Trailing empty cells to complete the last row -->
			for i := 0; i < trailingCells(data); i++ {
				<div class="bg-surface min-h-[80px]"></div>
			}
		</div>
	}
}

// dayCell renders a single day in the calendar grid. Shows season color
// as a subtle left border, moon phases on hover, and event chips.
templ dayCell(data CalendarViewData, day int) {
	<div class={
		"bg-surface min-h-[80px] p-1.5 relative group",
		templ.KV("ring-2 ring-inset ring-accent/40", data.IsToday(day)),
	} style={ seasonBorderStyle(data.CurrentSeason(day)) }>
		<!-- Day number + add button -->
		<div class="flex items-center justify-between mb-1">
			<span class={
				"text-xs font-medium w-6 h-6 flex items-center justify-center rounded-full",
				templ.KV("bg-accent text-white", data.IsToday(day)),
				templ.KV("text-fg-body", !data.IsToday(day)),
			}>
				{ strconv.Itoa(day) }
			</span>
			<!-- Quick add button visible on hover (Scribe+) -->
			if data.IsScribe {
				<button
					class="hidden group-hover:flex w-5 h-5 items-center justify-center rounded text-[10px] text-fg-muted hover:text-accent hover:bg-accent/10 transition-colors"
					onclick={ templ.ComponentScript{Call: fmt.Sprintf("openEventModal(%d, %d, %d)", data.Year, data.MonthIndex, day)} }
					title="Add event"
				>
					<i class="fa-solid fa-plus"></i>
				</button>
			}
		</div>
		<!-- Events for this day -->
		for _, evt := range data.EventsForDay(day) {
			<div
				class={
					"text-[10px] leading-tight px-1.5 py-0.5 rounded truncate mb-0.5 cursor-default",
					templ.KV("bg-accent/15 text-accent", evt.Visibility == "everyone"),
					templ.KV("bg-amber-500/15 text-amber-400", evt.Visibility == "dm_only"),
				}
				title={ eventTooltip(evt) }
			>
				if evt.EntityID != nil && evt.EntityIcon != "" {
					<i class={ "fa-solid " + evt.EntityIcon, "mr-0.5" } style={ fmt.Sprintf("color:%s", evt.EntityColor) }></i>
				}
				if evt.Category != nil && *evt.Category != "" {
					<span class="opacity-60">{ categoryIcon(*evt.Category) }</span>
					{ " " }
				}
				{ evt.Name }
			</div>
		}
	</div>
}

// eventCreateModal renders the Alpine.js-powered event creation modal.
templ eventCreateModal(data CalendarViewData) {
	<div
		id="event-modal"
		class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/50"
		onclick="if(event.target===this)this.classList.add('hidden')"
	>
		<div class="card p-6 w-full max-w-md space-y-4" x-data="{ loading: false }">
			<div class="flex items-center justify-between">
				<h2 class="text-lg font-semibold text-fg">New Event</h2>
				<button class="text-fg-muted hover:text-fg" onclick="document.getElementById('event-modal').classList.add('hidden')">
					<i class="fa-solid fa-xmark"></i>
				</button>
			</div>
			<form id="event-create-form" class="space-y-3">
				<div>
					<label class="block text-xs font-medium text-fg-body mb-1">Name</label>
					<input type="text" name="name" class="input w-full" required placeholder="Event name"/>
				</div>
				<div>
					<label class="block text-xs font-medium text-fg-body mb-1">Description</label>
					<textarea name="description" class="input w-full" rows="2" placeholder="Optional description"></textarea>
				</div>
				<div class="grid grid-cols-3 gap-2">
					<div>
						<label class="block text-xs font-medium text-fg-body mb-1">Year</label>
						<input type="number" name="year" id="evt-year" class="input w-full" value={ strconv.Itoa(data.Year) }/>
					</div>
					<div>
						<label class="block text-xs font-medium text-fg-body mb-1">Month</label>
						<input type="number" name="month" id="evt-month" class="input w-full" value={ strconv.Itoa(data.MonthIndex) }/>
					</div>
					<div>
						<label class="block text-xs font-medium text-fg-body mb-1">Day</label>
						<input type="number" name="day" id="evt-day" class="input w-full" value="1"/>
					</div>
				</div>
				<div class="grid grid-cols-2 gap-2">
					<div>
						<label class="block text-xs font-medium text-fg-body mb-1">Visibility</label>
						<select name="visibility" class="input w-full">
							<option value="everyone">Everyone</option>
							<option value="dm_only">DM Only</option>
						</select>
					</div>
					<div>
						<label class="block text-xs font-medium text-fg-body mb-1">Category</label>
						<select name="category" class="input w-full">
							<option value="">None</option>
							<option value="holiday">Holiday</option>
							<option value="battle">Battle</option>
							<option value="quest">Quest</option>
							<option value="birthday">Birthday</option>
							<option value="festival">Festival</option>
							<option value="travel">Travel</option>
							<option value="custom">Custom</option>
						</select>
					</div>
				</div>
				<div class="flex items-center gap-3">
					<label class="flex items-center gap-2 text-xs text-fg-body">
						<input type="checkbox" name="is_recurring" class="rounded"/>
						Recurring yearly
					</label>
				</div>
				<div>
					<label class="block text-xs font-medium text-fg-body mb-1">Link Entity (ID)</label>
					<input type="text" name="entity_id" class="input w-full" placeholder="Optional entity ID"/>
				</div>
				<div class="flex justify-end gap-2 pt-2">
					<button type="button" class="btn-secondary text-xs" onclick="document.getElementById('event-modal').classList.add('hidden')">
						Cancel
					</button>
					<button type="submit" class="btn-primary text-xs" x-bind:disabled="loading">
						<i class="fa-solid fa-plus mr-1"></i> Create Event
					</button>
				</div>
			</form>
			<script>
				document.getElementById('event-create-form').addEventListener('submit', async function(e) {
					e.preventDefault();
					const form = e.target;
					const fd = new FormData(form);
					const body = {
						name: fd.get('name'),
						year: parseInt(fd.get('year')),
						month: parseInt(fd.get('month')),
						day: parseInt(fd.get('day')),
						visibility: fd.get('visibility'),
						is_recurring: fd.has('is_recurring'),
						recurrence_type: fd.has('is_recurring') ? 'yearly' : null,
					};
					const desc = fd.get('description');
					if (desc) body.description = desc;
					const cat = fd.get('category');
					if (cat) body.category = cat;
					const eid = fd.get('entity_id');
					if (eid) body.entity_id = eid;

					const campaignID = window.location.pathname.split('/')[2];
					const csrfMeta = document.querySelector('meta[name="csrf-token"]');
					const headers = { 'Content-Type': 'application/json' };
					if (csrfMeta) headers['X-CSRF-Token'] = csrfMeta.content;

					try {
						const resp = await fetch('/campaigns/' + campaignID + '/calendar/events', {
							method: 'POST', headers, body: JSON.stringify(body),
						});
						if (resp.ok) {
							document.getElementById('event-modal').classList.add('hidden');
							form.reset();
							window.location.reload();
						} else {
							const data = await resp.json().catch(() => ({}));
							alert(data.message || 'Failed to create event');
						}
					} catch (err) {
						alert('Network error: ' + err.message);
					}
				});

				function openEventModal(year, month, day) {
					document.getElementById('evt-year').value = year;
					document.getElementById('evt-month').value = month;
					document.getElementById('evt-day').value = day;
					document.getElementById('event-modal').classList.remove('hidden');
				}
			</script>
		</div>
	</div>
}

// EntityEventsSection renders a list of calendar events linked to an entity.
// Loaded via HTMX lazy-load on entity show pages.
templ EntityEventsSection(cc *campaigns.CampaignContext, cal *Calendar, events []Event) {
	<div class="mt-6">
		<div class="flex items-center gap-2 mb-3 px-1">
			<i class="fa-solid fa-calendar-days text-fg-muted text-sm"></i>
			<h3 class="text-sm font-semibold text-fg">Calendar Events</h3>
			<span class="text-xs text-fg-muted">({ strconv.Itoa(len(events)) })</span>
		</div>
		<div class="card divide-y divide-edge">
			for _, evt := range events {
				<a
					href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/calendar?year=%d&month=%d", cc.Campaign.ID, evt.Year, evt.Month)) }
					class="flex items-center justify-between px-4 py-2.5 hover:bg-surface-alt transition-colors"
				>
					<div class="flex items-center gap-2 min-w-0">
						if evt.Category != nil && *evt.Category != "" {
							<span class="text-xs opacity-60">{ categoryIcon(*evt.Category) }</span>
						}
						<span class="text-sm text-fg truncate">{ evt.Name }</span>
						if evt.IsRecurring {
							<span class="text-[10px] text-fg-muted">(yearly)</span>
						}
					</div>
					<span class="text-xs text-fg-secondary whitespace-nowrap ml-2">
						{ formatEventDate(cal, evt) }
					</span>
				</a>
			}
		</div>
	</div>
}

// formatEventDate returns a human-readable date string for an event.
func formatEventDate(cal *Calendar, evt Event) string {
	monthName := fmt.Sprintf("Month %d", evt.Month)
	if evt.Month >= 1 && evt.Month <= len(cal.Months) {
		monthName = cal.Months[evt.Month-1].Name
	}
	s := fmt.Sprintf("%d %s %d", evt.Day, monthName, evt.Year)
	if cal.EpochName != nil && *cal.EpochName != "" {
		s += " " + *cal.EpochName
	}
	return s
}

// Helper functions for template navigation.

func prevYear(d CalendarViewData) int {
	y, _ := d.PrevMonth()
	return y
}

func prevMonth(d CalendarViewData) int {
	_, m := d.PrevMonth()
	return m
}

func nextYear(d CalendarViewData) int {
	y, _ := d.NextMonth()
	return y
}

func nextMonth(d CalendarViewData) int {
	_, m := d.NextMonth()
	return m
}

// trailingCells calculates empty cells needed to complete the last row.
func trailingCells(d CalendarViewData) int {
	wl := d.Calendar.WeekLength()
	if wl == 0 {
		return 0
	}
	totalCells := d.StartWeekdayOffset() + d.CurrentMonthDays()
	remainder := totalCells % wl
	if remainder == 0 {
		return 0
	}
	return wl - remainder
}

// moonPhaseIcon returns a unicode moon phase character based on phase value (0-1).
func moonPhaseIcon(phase float64) string {
	switch {
	case phase < 0.125:
		return "\U0001F311" // New moon
	case phase < 0.25:
		return "\U0001F312" // Waxing crescent
	case phase < 0.375:
		return "\U0001F313" // First quarter
	case phase < 0.5:
		return "\U0001F314" // Waxing gibbous
	case phase < 0.625:
		return "\U0001F315" // Full moon
	case phase < 0.75:
		return "\U0001F316" // Waning gibbous
	case phase < 0.875:
		return "\U0001F317" // Last quarter
	default:
		return "\U0001F318" // Waning crescent
	}
}

// seasonBorderStyle returns a CSS style for the season color left border.
func seasonBorderStyle(s *Season) string {
	if s == nil || s.Color == "" {
		return ""
	}
	return fmt.Sprintf("border-left: 3px solid %s", s.Color)
}

// eventTooltip builds a tooltip string for an event chip.
func eventTooltip(evt Event) string {
	tip := evt.Name
	if evt.EntityName != "" {
		tip += " (" + evt.EntityName + ")"
	}
	if evt.Description != nil && *evt.Description != "" {
		tip += "\n" + *evt.Description
	}
	if evt.IsRecurring {
		tip += " [recurring]"
	}
	return tip
}

// categoryIcon returns a small icon for an event category.
func categoryIcon(cat string) string {
	switch cat {
	case "holiday":
		return "\u2B50" // star
	case "battle":
		return "\u2694" // swords
	case "quest":
		return "\u2757" // exclamation
	case "birthday":
		return "\U0001F382" // cake
	case "festival":
		return "\U0001F389" // party popper
	case "travel":
		return "\U0001F6B6" // walking
	default:
		return ""
	}
}
