// form.templ renders the create/edit entity form with dynamic field rendering
// based on the entity type's field definitions.

package entities

import (
	"fmt"
	"github.com/keyxmakerx/chronicle/internal/plugins/campaigns"
	"github.com/keyxmakerx/chronicle/internal/templates/layouts"
	"strconv"
)

// EntityNewPage renders the full entity creation page.
templ EntityNewPage(cc *campaigns.CampaignContext, entityTypes []EntityType, preselect int, parentEntity *Entity, csrfToken, errMsg string) {
	@layouts.App("New Page - " + cc.Campaign.Name) {
		<div class="max-w-2xl mx-auto">
			<nav class="text-sm text-fg-secondary mb-4">
				<a href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/entities", cc.Campaign.ID)) } class="hover:text-fg-body">Pages</a>
				<span class="mx-1">/</span>
				<span class="text-fg">New</span>
			</nav>
			<h1 class="text-2xl font-bold text-fg mb-6">Create Page</h1>
			@EntityCreateFormComponent(cc, entityTypes, preselect, parentEntity, csrfToken, errMsg)
		</div>
	}
}

// EntityEditPage renders the full entity edit page.
templ EntityEditPage(cc *campaigns.CampaignContext, entity *Entity, entityType *EntityType, entityTypes []EntityType, parentEntity *Entity, csrfToken, errMsg string) {
	@layouts.App("Edit " + entity.Name + " - " + cc.Campaign.Name) {
		<div class="max-w-2xl mx-auto">
			<nav class="text-sm text-fg-secondary mb-4">
				<a href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/entities", cc.Campaign.ID)) } class="hover:text-fg-body">Pages</a>
				<span class="mx-1">/</span>
				<a href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/entities/%s", cc.Campaign.ID, entity.ID)) } class="hover:text-fg-body">{ entity.Name }</a>
				<span class="mx-1">/</span>
				<span class="text-fg">Edit</span>
			</nav>
			<h1 class="text-2xl font-bold text-fg mb-6">Edit { entity.Name }</h1>
			@EntityEditFormComponent(cc, entity, entityType, parentEntity, csrfToken, errMsg)
		</div>
	}
}

// EntityCreateFormComponent renders the entity creation form.
templ EntityCreateFormComponent(cc *campaigns.CampaignContext, entityTypes []EntityType, preselect int, parentEntity *Entity, csrfToken, errMsg string) {
	<div id="entity-form">
		<form
			class="card p-8 space-y-6"
			method="POST"
			action={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/entities", cc.Campaign.ID)) }
			hx-post={ fmt.Sprintf("/campaigns/%s/entities", cc.Campaign.ID) }
			hx-target="#entity-form"
			hx-swap="outerHTML"
		>
			<input type="hidden" name="csrf_token" value={ csrfToken }/>

			if errMsg != "" {
				<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md text-sm" role="alert">
					{ errMsg }
				</div>
			}

			<div>
				<label for="entity_type_id" class="block text-sm font-medium text-fg-body mb-1">Category</label>
				<select id="entity_type_id" name="entity_type_id" required class="input w-full">
					<option value="">Select a category...</option>
					for _, et := range entityTypes {
						if et.Enabled {
							<option
								value={ strconv.Itoa(et.ID) }
								selected?={ et.ID == preselect }
							>{ et.Name }</option>
						}
					}
				</select>
			</div>

			<div>
				<label for="name" class="block text-sm font-medium text-fg-body mb-1">Name</label>
				<input
					type="text"
					id="name"
					name="name"
					required
					autofocus
					class="input w-full"
					placeholder="e.g., Gandalf, Rivendell, The One Ring"
					maxlength="200"
				/>
			</div>

			<div>
				<label for="type_label" class="block text-sm font-medium text-fg-body mb-1">Descriptor (optional)</label>
				<input
					type="text"
					id="type_label"
					name="type_label"
					class="input w-full"
					placeholder="e.g., City, NPC, Artifact"
					maxlength="100"
				/>
				<p class="mt-1 text-xs text-fg-secondary">A short descriptor shown next to the type badge, e.g. "City" for a Location or "Rogue" for a Character.</p>
			</div>

			@parentSelector(cc.Campaign.ID, parentEntity)

			<div class="flex items-center">
				<input type="hidden" name="is_private" value="false"/>
				<input
					type="checkbox"
					id="is_private"
					name="is_private"
					value="true"
					class="rounded border-edge text-blue-600 mr-2"
				/>
				<label for="is_private" class="text-sm text-fg-body">Private (visible to GM only)</label>
			</div>

			<div class="flex items-center space-x-4">
				<button type="submit" class="btn-primary">Create Page</button>
				<a href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/entities", cc.Campaign.ID)) } class="btn-secondary">Cancel</a>
			</div>
		</form>
	</div>
}

// EntityEditFormComponent renders the entity edit form with dynamic fields.
templ EntityEditFormComponent(cc *campaigns.CampaignContext, entity *Entity, entityType *EntityType, parentEntity *Entity, csrfToken, errMsg string) {
	<div id="entity-form">
		<form
			class="card p-8 space-y-6"
			method="POST"
			action={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/entities/%s", cc.Campaign.ID, entity.ID)) }
			hx-put={ fmt.Sprintf("/campaigns/%s/entities/%s", cc.Campaign.ID, entity.ID) }
			hx-target="#entity-form"
			hx-swap="outerHTML"
		>
			<input type="hidden" name="_method" value="PUT"/>
			<input type="hidden" name="csrf_token" value={ csrfToken }/>

			if errMsg != "" {
				<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md text-sm" role="alert">
					{ errMsg }
				</div>
			}

			<div>
				<label for="name" class="block text-sm font-medium text-fg-body mb-1">Name</label>
				<input
					type="text"
					id="name"
					name="name"
					value={ entity.Name }
					required
					class="input w-full"
					maxlength="200"
				/>
			</div>

			<div>
				<label for="type_label" class="block text-sm font-medium text-fg-body mb-1">Descriptor (optional)</label>
				<input
					type="text"
					id="type_label"
					name="type_label"
					if entity.TypeLabel != nil {
						value={ *entity.TypeLabel }
					}
					class="input w-full"
					placeholder="e.g., City, NPC, Artifact"
					maxlength="100"
				/>
			</div>

			@parentSelector(cc.Campaign.ID, parentEntity)

			<!-- Dynamic fields from entity type -->
			if entityType != nil && len(entityType.Fields) > 0 {
				<fieldset class="space-y-4 pt-4 border-t border-edge">
					<legend class="text-sm font-semibold text-fg">Type Fields</legend>
					for _, field := range entityType.Fields {
						@DynamicField(field, entity.FieldsData)
					}
				</fieldset>
			}

			<div>
				<label for="entry" class="block text-sm font-medium text-fg-body mb-1">Entry Content</label>
				<textarea
					id="entry"
					name="entry"
					class="input w-full h-48"
					placeholder="Write about this entity..."
				>
					if entity.Entry != nil {
						{ *entity.Entry }
					}
				</textarea>
				<p class="mt-1 text-xs text-fg-secondary">Plain text for now. Rich text editor coming soon.</p>
			</div>

			<div class="flex items-center">
				<input type="hidden" name="is_private" value="false"/>
				<input
					type="checkbox"
					id="is_private"
					name="is_private"
					value="true"
					checked?={ entity.IsPrivate }
					class="rounded border-edge text-blue-600 mr-2"
				/>
				<label for="is_private" class="text-sm text-fg-body">Private (visible to GM only)</label>
			</div>

			<div class="flex items-center space-x-4">
				<button type="submit" class="btn-primary">Save Changes</button>
				<a href={ templ.SafeURL(fmt.Sprintf("/campaigns/%s/entities/%s", cc.Campaign.ID, entity.ID)) } class="btn-secondary">Cancel</a>
			</div>
		</form>
	</div>
}

// DynamicField renders a single form input based on a field definition.
// The current value is read from the entity's fields_data map.
templ DynamicField(field FieldDefinition, fieldsData map[string]any) {
	<div>
		<label for={ "field_" + field.Key } class="block text-sm font-medium text-fg-body mb-1">{ field.Label }</label>
		if field.Type == "textarea" {
			<textarea
				id={ "field_" + field.Key }
				name={ "field_" + field.Key }
				class="input w-full h-24"
			>
				if val, ok := fieldsData[field.Key]; ok && val != nil {
					{ fmt.Sprintf("%v", val) }
				}
			</textarea>
		} else if field.Type == "select" && len(field.Options) > 0 {
			<select id={ "field_" + field.Key } name={ "field_" + field.Key } class="input w-full">
				<option value="">Select...</option>
				for _, opt := range field.Options {
					<option
						value={ opt }
						selected?={ fieldValueMatches(fieldsData, field.Key, opt) }
					>{ opt }</option>
				}
			</select>
		} else if field.Type == "checkbox" {
			<input type="hidden" name={ "field_" + field.Key } value=""/>
			<input
				type="checkbox"
				id={ "field_" + field.Key }
				name={ "field_" + field.Key }
				value="true"
				checked?={ fieldValueMatches(fieldsData, field.Key, "true") }
				class="rounded border-edge text-blue-600"
			/>
		} else {
			<input
				type={ fieldInputType(field.Type) }
				id={ "field_" + field.Key }
				name={ "field_" + field.Key }
				if val, ok := fieldsData[field.Key]; ok && val != nil {
					value={ fmt.Sprintf("%v", val) }
				}
				class="input w-full"
			/>
		}
	</div>
}

// parentSelector renders a searchable parent entity picker. Uses Alpine.js
// for client-side search with the existing entity search JSON endpoint.
templ parentSelector(campaignID string, parentEntity *Entity) {
	<div
		x-data={ fmt.Sprintf(`{
			open: false,
			query: '',
			results: [],
			selectedID: '%s',
			selectedName: '%s',
			loading: false,
			async search() {
				if (this.query.length < 2) { this.results = []; return; }
				this.loading = true;
				try {
					const resp = await fetch('/campaigns/%s/entities/search?q=' + encodeURIComponent(this.query), {
						headers: { 'Accept': 'application/json' }
					});
					if (resp.ok) { const data = await resp.json(); this.results = data.results || []; }
				} finally { this.loading = false; }
			},
			select(entity) {
				this.selectedID = entity.id;
				this.selectedName = entity.name;
				this.query = '';
				this.results = [];
				this.open = false;
			},
			clear() {
				this.selectedID = '';
				this.selectedName = '';
				this.query = '';
				this.results = [];
			}
		}`, parentSelectorID(parentEntity), parentSelectorName(parentEntity), campaignID) }
		class="relative"
	>
		<label class="block text-sm font-medium text-fg-body mb-1">Parent Page (optional)</label>
		<input type="hidden" name="parent_id" x-bind:value="selectedID"/>

		<!-- Selected parent display -->
		<div x-show="selectedID" class="flex items-center gap-2 p-2 rounded-md bg-surface-alt border border-edge">
			<span class="text-sm text-fg" x-text="selectedName"></span>
			<button type="button" @click="clear()" class="ml-auto text-xs text-fg-muted hover:text-red-500 transition-colors" title="Remove parent">
				<i class="fa-solid fa-xmark"></i>
			</button>
		</div>

		<!-- Search input (shown when no parent selected) -->
		<div x-show="!selectedID">
			<input
				type="text"
				x-model="query"
				@input.debounce.300ms="search()"
				@focus="open = true"
				@click.outside="open = false"
				class="input w-full"
				placeholder="Search for a parent page..."
			/>

			<!-- Dropdown results -->
			<div
				x-show="open && (results.length > 0 || loading)"
				x-cloak
				class="absolute z-20 mt-1 w-full bg-surface border border-edge rounded-lg shadow-lg max-h-48 overflow-y-auto"
			>
				<template x-if="loading">
					<div class="px-3 py-2 text-xs text-fg-muted">Searching...</div>
				</template>
				<template x-for="entity in results" x-bind:key="entity.id">
					<button
						type="button"
						@click="select(entity)"
						class="w-full px-3 py-2 text-left text-sm text-fg hover:bg-surface-alt transition-colors flex items-center gap-2"
					>
						<span class="truncate" x-text="entity.name"></span>
						<span class="text-xs text-fg-muted ml-auto" x-text="entity.type_name"></span>
					</button>
				</template>
			</div>
		</div>

		<p class="mt-1 text-xs text-fg-secondary">Nest this page under another page to create a hierarchy.</p>
	</div>
}

// parentSelectorID returns the parent entity ID for the selector, or empty string.
func parentSelectorID(parent *Entity) string {
	if parent != nil {
		return parent.ID
	}
	return ""
}

// parentSelectorName returns the parent entity name for the selector, or empty string.
func parentSelectorName(parent *Entity) string {
	if parent != nil {
		return parent.Name
	}
	return ""
}

// fieldInputType maps field definition types to HTML input types.
func fieldInputType(t string) string {
	switch t {
	case "number":
		return "number"
	case "url":
		return "url"
	default:
		return "text"
	}
}

// fieldValueMatches checks if a field's stored value matches the expected value.
func fieldValueMatches(fieldsData map[string]any, key, expected string) bool {
	val, ok := fieldsData[key]
	if !ok || val == nil {
		return false
	}
	return fmt.Sprintf("%v", val) == expected
}
